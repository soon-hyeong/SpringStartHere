# 2. 스프링 컨텍스트 : 빈 정의

기본적으로 스프링은 애플리케이션에서 어떤 객체도 알지 못한다  
스프링이 객체를 볼 수 있게 하려면 컨텍스트에 객체를 추가해야 한다  
이때 객체 인스턴스를 bean이라고 한다


## 2.1 아파치 메이븐(Apache Maven) 프로젝트 생성
### 빌드 도구
앱을 더 쉽게 빌드하는데 사용하는 소프트,웨어. 앱 빌드 일부인 작업을 수동으로 수행하는 대신 빌드 도구가 수행하도록 구성
- 앱에 필요한 의존성 내려 받기
- 테스트 실행
- 구문이 정의한 규칙 준수 여부 검증
- 보안 취약점 확인
- 앱 컴파일
- 실행 가능한 아카이브에 앱 패키징


### 프로젝트 생성
- src 폴더: 소스 폴더, 앱에 속한 모든 것을 넣는다
	- main 폴더: 애플리케이션의 소스코드를 저장. 자바 코드와 구성정보가 java 및 resources라는 두 하위 폴더에 개별적으로 포함
		- java 폴더: 앱의 자바 소스
		- resource 폴더: 프로퍼티 파일이나 구성 같은 리소스 저장
	- test 폴더: 단위 테스트의 소스 코드를 저장. 
- pom.xml 파일: 새 종속성 추가처럼 메이븐 프로젝트 구성을 작성하는 파일, 메이븐 프로젝트에 추가하려면 - - pom.xml 파일을 변경해야 한다.  
	\<dependencies>\<dependency>로 의존성 추가  
	스프링은 모듈형이라, 스프링 에코시스템의 일부 기능을 사용할 때 앱에 스프링 전체를 추가할 필요 없이 사용할 부분만 추가하면 된다.  
	pom.xml 파일에 의존성을 추가하면 IDE가 종속성을 내려받아 External Liraries 폴더에서 추가된 의존성을 찾을 수 있다.

## 스프링 컨텍스트에 새로운 빈 추가
스프링 빈을 추가하는 방법
### @Bean 애너테이션 사용 방법
1. 프로젝트에서 구성 클래스 정의하기  
	- 첫 번째 단계는 프로젝트에서 구성 클래스를 생성하는 것이다. @Configuration이 스프링 구성 애너테이션으로 지정되어있다.
2. 빈을 반환하는 메서드를 생성하고 @Bean 애터네이션을 메서드에 추가하기  
   	- 컨텍스트에 추가하려는 객체 인스턴스를 반환하는 메서드를 구성 클래스에 추가하고 @Bean 애너테이션으로 메서드에 주석을 추가한다.   
	- 스프링 컨텍스트에 모든 종류의 객체를 추가할 수 있다(ex: String, Integer ...).  
	- Bean 애너테이션이 붙은 메서드를 더 선언하기만 하면 동일한 타입의 인스턴스를 원하는 만큼 선언할 수 있다.
```java
	@Configuration // Configuration 애너테이션을 사용하여 이 클래스를 스프링 구성 클래스로 정의
	public class ProjectConfig {
		@Bean // Bean 애너테이션을 추가하여 스프링에 컨텍스트가 초기화될 때 이 메서드를 호출하고 반환된 값을 컨텍스트에 추가하라고 지시
		@Primary // 스프링 컨텍스트에 동일한 종류의 빈이 여러 개 있다면 그 중 하나를 기본(primary) 빈으로 만들 수 있다. @Primary 에너테이션을 사용하여 기본으로 설정하려는 빈을 표시한다. 기본 빈은 서택할 빈이 여러 개 있고 사용자가 이름을 지정하지 않을 때 스프링이 선택하는 빈이다.
		Parrot parrot() {
			var p = new Parrot();
			p.setName("Koko");
			return p;
		}

		@Bean(name="miki")
		Parrot parrot2() {
			var p = new Parrot();
			p.setName("Miki");
			return p;
		}

		@Bean(value="Riki")
		Parrot parrot3() {
			var p = new Parrot();
			p.setName("Riki");
			return p;
		}
	}
```
3. 새로 생성된 구성 클래스로 스프링이 컨텍스트를 초기화하도록 만들기
	위 단계에서 구현한 구성 클래스를 사용하도록 스프링 컨텍스트의 인스턴스화를 변경한다.  
```java
	public class Main{
		public static void main(String[] args){
			var context = new AnnotationConfigApplicationContext(ProjectConfig.class);
			Parrot p= context.getBean(Parrot.class); // 스프링 컨텍스트에서 Parrot 타입을 가져온다
			System.out.println(p.getName());
			Parrot p2 = context.getBean("parrot2", Parrot.class);
			System.out.println(p.getName());
		}
	}
```
	
### 스테레오타입(stereotype) 애너테이션으로 스프링 컨텍스트에 빈 추가
- 스테레오타입 애너테이션을 사용하면 더 적은 코드로 스프링이 컨텍스트에 빈을 추가하도록 지시할 수 있다.   
- @Component 는 가장 기본적인 스테레오타입 애너테이션으로, 클래스 위에 추가하여 클래스를 컴포넌트로 표시할 수 있다.   
- 앱이 스프링 컨텍스트를 생성하면 스프링은 컴포넌트로 표시된 클래스의 인스턴스를 생성하고 해당 인스턴스를 컨텍스트에 추가한다.
- 이 방식을 사용하면 스테레오타입 애너테이션으로 지정된 클래스를 찾을 위치를 스프링에 알려 주는 구성 클래스가 필요하다.

#### 수행해야할 단계
1. @component 애너테이션으로 스프링이 해당 컨텍스트에 인스턴스를 추가할 클래스를 표시한다.
2. 구성 클래스 위에 @ComponentScan 애너테이션으로 표시한 클래스를 어디에서 찾을 수 있는지 스프링에 지시한다. 
```java
@Component
pulic class Parrot {

	private String name;
	private String getName(){
		return name;
	}

	public void setName(String name){
		this.name = name;
	}
}
```
기본적으로 스프링은 스테레오타입 에너테이션으로 지정된 클래스를 검색하지 않기 때문에 코드를 그대로 두면 스프링은 스프링 컨텍스트에 Parrot 타입의 빈을 추가하지 않는다.  
스프링에 스테레오타입 에너테이션으로 지정된 클래스들을 검색하도록 지시하려면 구성 클래스에 @ComponentScan 애너테이션을 추가해야 한다.  
@ComponentScan 애너테이션으로 지정된 클래스가 있는 패키지들을 열거하여 매개변수(basePackages)에 제공해야 한다.
```java
@Configuration
@ComponentScan(basePackages="main")
public class ProjectConfig{

}
```
main 메서드에서 스프링이 컨텍스트에서 빈을 생성하고 추가한다는 것을 확인한다.
```java
public class Main{

	public static void main(String[] args){
		var context = new AnnotationConfigApplicationContext(ProjectConfig.class);
		Parrot p = context.getBean(Parrot.class);
		System.out.println(p); // 스프링 컨텍스트에서 가져온 인스턴스를 기본 String 형식으로 출력
		System.out.println(p.getName()); // 스프링이 컨텍스트에 추가한 Parrot 인스턴스에 아직 이름을 설정하지 않았으므로 null 출력
	}
}
```

### @Bean애너테이션 사용과 스테레오타입 애너테이션 사용 비교
#### @Bean 애너테이션 사용
1. 스프링 컨텍스트에 추가할 인스턴스의 생성을 완전히 제어할 수 있다. @Bean이 달린 메서드 안에서 인스턴스를 생성하고 구성하는 것은 사용자의 책임이다. 스프링은 해당 인스턴스만 받아 컨텍스트에 그대로 추가한다.
2. @Bean애너테이션을 사용하면 동일한 타입의 인스턴스를 스프링 컨텍스트에 더 추가할 수 있다. 2.2.1절에서 우리는 스프링 컨텍스트에 Parrot 인스턴스 세 개를 추가한다.
3. @Bean 애너테이션을 사용하여 스프링 컨텍스트에 모든 객체 인스턴스를 추가할 수 있다. 즉, 인스턴스를 정의한 클래스가 앱 내에서 정의되지 않아도 추가할 수 있다. (ex:String, Integer)
4. 생성하는 각 빈에 대해 별도의 메서드를 작성해야 하므로 앱에 사용구 코드가 추가된다. 이런 이유로 프로젝트에서 @Bean을 사용하기보다는 스테레오타입 애너테이션을 선호한다.
#### @스테레오타입 애너테이션 사용
1. 프레임워크가 인스턴스를 생성한 후에만 인스턴스를 제어할 수 있다.
2. 이렇게 하면 컨텍스트에 클래스의 인스턴스를 하나만 추가할 수 있다.
3. 스테레오타입 애너테이션은 애플리케이션이 소유한 클래스의 빈을 생성하는 데만 사용할 수 있다.
4. 스테레오타입 애너테이션을 사용하여 스프링 컨텍스트에 빈을 추가해도 앱에 사용구 코드가 추가되지 않는다.

### 프로그래밍 방식으로 스프링 컨텍스트에 빈 추가
스프링5에서는 스프링 컨텍스트에 프로그래밍 방식으로 빈을 추가하는 방법이 소개되었는데, 컨텍스트 인스턴스의 메서드를 호출하여 컨텍스트에 새 인스턴스를 직접 추가할 수 있어 유연성이 매우 뛰어나다. 컨텍스트에 빈을 추가하는 사용자 재정의 방법을 구현하고 싶지만 @Bean 또는 스테레오타입 애너테이션 방식이 요구에 충족되지 않을 때 이 방식을 사용한다.  

애플리케이션의 특정 구성 정보에 따라 스프링 컨텍스트에 특정 빈을 등록해야한다고 가정. @Bean 및 스테레오 타입 애너테이션을 사용하면 시나리오 대부분을 구성할 수 있지만 다음 코드에서 제시된 작업을 수행할 수 없음.
```java
if(condition){
	registerBean(b1); // 조건이 참이면 스프링 컨텍스트에 특정 빈을 추가한다
} else {
	registerBean(b2); // 참이 아니면 스프링 컨텍스트에 다른 빈을 추가한다
}
```

프로그래밍 방식으로 스프링 컨텍스트에 빈을 추가하려면 ApplicationContext 인스턴스의 registerBean() 메서드를 호출하면 된다.
registerBean()에는 다음 코드에 표시된 것처럼 매개변수 네 개가 있다.
```java
<T> void registerBean(
	String beanName,
	Clas<T> beanClass,
	Supplier<T> supplier,
	BeanDefinitionCustomizeer... cusomizers);
```
1. beanName : 스프링 컨텍스트에서 추가할 빈 이름, 이름을 지정할 필요 없다면 null 값을 사용할 수 있다.
2. beanClass : 컨텍스트에 추가할 빈을 정의하는 클래스. (ex: Parrot.class)
3. supplier: Supplier의 구현체. 컨텍스트에 추가할 인스턴스 값을 전달한다. Supplier 함수형 인터페이스의 목적은 매개변수 없이 사용자가 정의한 값을 반환하는 것이다.
4. ...: BeanDefinitionCustomizer의 varargs. BeanDefinitionCustomizer는 빈의 다양한 특징을 구성하려고 구현하는 인터페이스. 완전히 생략하거나 BeanDefinitionCustomizer 타입의 값을 여러개 지정할 수 있다.

우선 구성 클래스를 생성한다
```java
@Configuration
public class ProjectConfig{

}
```
빈을 생성하는데 사용하는 Parrot 클래스를 정의한ㄷ
```java
public class Parrot {

	private String name;
	// getters와 setters 생략
}
```

프로젝트의 main 메서드에서 registerBean() 메서드로 스프링 컨텍스트에 Parrot 타입의 인스턴스를 추가한다.
```java
public class Main{

	public static void main(String[] args){
		var context = new AnnotationConfigApplicationContext(ProjectConfig.class);
		Parot x = new Parrot();
		x.setName("Kiki");

		Supplier<Parrot> parrotSupplier = () -> x; // 이 인스턴스를 반환할 Supplier를 정의

		context.registerBean("parrot1", Parrot.class, parrotSupplier); // registerBean() 메서드를 호출하여 이 인스턴스를 스프링 컨텍스트에 추가

		Parrot p = context.getBean(Parrot.class); // 컨텍스트에 있는 빈 검증위해서 이름 콘솔 출력
		System.out.println(p.getName());
	}
}
```

하나 이상의 빈 구성자(configurator) 인스턴스를 마지막 매개변수로 사용하여 추가할 빈의 다양한 특성을 설정할 수 있다. 예를 들으 다음 코드에 표시된 것처럼 registerBean() 메서드 호출을 수정해서 빈을 기본 빈으로 만들 수 있다.
```java
	context.registerBean("parrot1",
		Parrot.class,
		parrotSupplier,
		bc -> bc.setPrimary(true));
```

#### XML을 사용한 컨텍스트 구성
XML을 사용하면 별도의 구성 파일이 필요하다. 이 파일의 이름을 config.xml이라고 지정하고 메이브 프로젝트의 resources 폴더에 추가한다.

**`<beans>`** 태그는 이 XML 파일의 루트(root)이다. 
빈을 정의하는데 **/<bean>** XML 태그를 사용할 수 있으며, 인스턴스의 멤버변수에 값을 설정하기 위해서 /<Property> 태그를 사용한다.
XML 방식의 구성 개념은 특정 기능을 설정하려고 다양한 XML 태그를 사용하는 것이다. 
```xml
<?xml version="1.0" encoding="UTF-8">

<beans xmlns="http://www.springframework.org/shcma/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://www.springframework.org/shcema/beans
	   http://www.springframework.org/schema/beans/spring-beans.xsd">

	   <bean id="parrot1" class="main.Parrot">
			<Property name="name" value="Kiki" />
	   </bean>
<beans>
```
C
```java
public class Main{
	public static void main(String[] args){
		var contet = new ClassPathXmlApplicationContext("config.xml");
		Parrot p = context.getBean(Parrot.class);
		System.out.println(p.getName());
	}
}
```