# 3. 스프링 컨텍스트: 빈 작성

## 3.1 구성 파일에서 정의된 빈 간 관계 구현
@Bean 애너테이션으로 메서드를 지정하는 구성 클래스에서 정의된 두 빈 간 관계를 구현.  
스프링 구성을 사용하여 빈 간 관계를 설정할 때 이 방식을 접하게 됨  

스프링 컨텍스트에 앵무새(parrot)와 사람(person)이라는 두 인스턴스가 있다고 가정했을 때, 사람이 앵무새를 소유하도록 만들어보자.
이를 위해서는 두 인스턴스를 연결해야 하는데 여기에는 두가지 단계가 있다.
1. 스프링 컨텍스트에 사람과 앵무새 빈을 추가한다.
2. 사람과 앵무새 사이의 관계를 설정한다.

```java
@Configuration
public class ProjectConfig {

    @Bean
    Parrot parrot1(){
        Parrot p = new Parrot();
        p.setName("Koko");
        return p;
    }

    @Bean
    Person person1(){
        Person p = new Person();
        p.setName("Ella");
        return p;
    }
}
```
```java
package org.example;

public class Parrot {

    private String name;

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }

    @Override
    public String toString(){
        return "Parrot : " + name;
    }
}
```
```java
package org.example;

public class Person {

    private String name;
    private Parrot parrot;

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }

    public void setParrot(Parrot parrot){
        this.parrot = parrot;
    }

    public Parrot getParrot(){
        return this.parrot;
    }
    // getters와 setters 생략
}
```
아래 Main 클래스에서 두 인스턴스의 연결 여부를 확인하면, 앵무새와 사람 사이에 아무런 관계가 설정되지 않은 것을 확인할 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        var context = new AnnotationConfigApplicationContext(ProjectConfig.class);

        Person person = context.getBean(Person.class);

        Parrot parrot = context.getBean(Parrot.class);

        System.out.println("Persons's name: " + person.getName());

        System.out.println("Parrot's name: " + parrot.getName());

        System.out.println("Persons's parrot: " + person.getParrot());
    }
}
```

### 3.1.1 두 @Bean 메서드 간 직접 메서드를 호출하는 빈 작성
Person과 Parrot 클래스의 두 인스턴스 간 관계를 설정한다. 와이어링은 구성 클래스에서 한 메서드에서 다른 메서드를 호출하는 것이다.
사람과 앵무새 사이의 연결을 설정하고자 구성클래스에 약간의 변경을 수행한다.


다이렉트 와이어링(direct wiring)을 이용하여 빈 간 관계를 설정. 이 방식은 설정하려는 빈을 반환하는 메서드를 직접 호출하는 것을 의미. 의존 관계를 설정하는 빈을 정의하는 메서드에서 이 메서드를 호출해야 한다.

### 3.1.2 @Bean 메서드의 매개변수로 빈 와이어링하기
참조하려는 빈을 정의하는 메서드를 직접 호출하는 대신 해당 객체 타입의 메서드에 매개변수를 추가하고 스프링이 해당 매개변수를 이용하여 값을 제공하는 것에 의존하는 방식.
이 방식을 사용하면 참조하려는 빈이 @Bean으로 애너테이션된 메서드로 정의되든 2장에서 설명한 @Component 같은 스테레오 타입 애너테이션으로 정의되든 상관없다.

DI(의존성주입)은 프레임워크가 특정 필드 또는 매개변수에 값을 설정하는 기법. 스프링은 person() 메서드를 호출할 때 특정 값을 매개변수로 설정하고 이 메서드의 의존성을 해결한다.
DI는 IOC의 원리를 응용한 것으로, IOC는 프레임워크가 실행될 때 애플리케이션을 제어하는 것을 의미.

## 3.2 @Autowired 애너테이션을 사용한 빈 주입
빈을 정의하는 클래스를 변경할 수 있을 때(그 클래스가 의존성 일부가 아닐 때) @Autowired 라는 애너테이션을 참조하는 기법을 자주 사용하게 됨.
@Autowired 애너테이션을 사용하면 스프링이 컨텍스트에서 값을 주입하길 원하는 객체 속성을 표시하고, 의존성이필요한 객체를정의하는 클래스에 이 의도를 직접 표시할 수 있다.

@Autowired 애너테이션을 사용하는 방법에는 3가지 방법이 있다.
- 클래스의 필드에 값 주입하기
- 클래스의 생성자 매개변수로 값 주입하기
- setter로 값주입하기

### 3.2.1 @Autowired로 클래스 필드를 이용한 값 주입
가장 간단한 방식, 개념 증명(PoC), 테스트 작성에서 자주 사용
```java
@Component // 스테레오타입 애너테이션인 @Component는 스프링이 이 클래스(Person) 타입의 빈을 생성하고 추가하도록 지시한다
public class Person{

    private String name = "Ella";

    @Autowired
    private Parrot parrot; // 스프링이 스프링 컨텍스트에서 빈을 가져와 @Autowired 애너테이션된 필드 값에 직접 설정하도록 지시한다.

    //...
}
```

### 3.2.2 @Autowired를 사용하여 생성자로 값 주입
인스턴스를 정의하는 클래스의 생성자를 사용하여 스프링의 빈을 생성
프로덕션 코드에서 가장 자주 이용되는 방식
필드를 final로 정의할 수 있어, 필드를 초기화한 후에는 아무도 필드 값을 변경할 수 없음
```java
@Component // Component 스테레오타입 애너테이션은 스프링이 이 클래스(Person) 타입의 컨테스트에 빈을 생성하고 추가하도록 지시
public class Person{

    private String name = "Ella";

    private final Parrot parrot;

    @Autowired
    public Person(Parrot parrot){ //스프링이 Person 타입의 빈을 생성할 때 @Autowired 애너테이션이 달린 생성자를 호출. 스프링은 매개변수 값으로 컨텍스트에서 Parrot 타입의 빈을 전달
        this.parrot = parrot;
    }

    // ...
}
```

### 3.2.3 setter를 이용한 의존성 주입 사용
잘 안쓰는 방식.
가독성이 떨어지고, final 필드를 만들 수 없고, 테스트를 쉽게 만드는데 도움이 되지 않음.
```java
@Component
public class Person{

    private String name = "Ella";
    private Parrot parrot;

    // getters와 setters 생략

    @Autowired
    public void setParrot(Parrt parrot){
        this.parrot = parrot;
    }
}
```

### 3.3 순환 의존성 다루기
순환 의존성은 빈(빈 A)을 생성하기 위해 스프링이 아직 없는 다른 빈(빈 B)을 주입해야 하는 상황을 의미한다. 하지만 빈 B도 빈 A에 대한 의존성이 필요하다. 따라서 빈 B를 생성하려면 먼저 빈 A가 있어야 한다. 스프링은 교착 상태에 빠진다.

순환의존성을 피하기 위해서는 생성을 위해 다른 객체에 의존해야하는 객체를 정의하지 않는지 확인해야 한다. 한 객체에서 다른 객체로 의존성을 갖는 것은 잘못된 클래스 설계이고, 코드를 재작성해야 한다.
```java
public class Person {

    private final Parrot parrot;

    @Autowired
    public Person(Parrot parrot){
        this.parrot = parrot; // 스프링은 Person 인스턴스를 생성하는데 Parrot 빈이 필요하다.
    }
}
```
```java
public class Parrot{

    private String name = "Koko";
    private final Person person;

    @Autowired
    public Parrot(Person person){
        this.person = person;
    }

    // 코드 생략
}
```
위와 같은 구성으로 앱을 실행하면 예외가 발생한다.

## 3.4 스프링 컨텍스트에서 여러 빈 중 선택하기
스프링에서 매개변수 또는 클래스 필드에 값을 주입할 때 동일한 타입의 빈이 여러 개 있을 때의 의존성 주입 방법
1. 매개변수의 식별자가 컨텍스트의 빈 중 하나의 빈 이름과 일치하는 경우(값을 반환하는 @Bean으로 애너테이션도 메서드 이름과 동일하다). 이때 스프링은 매개변수와 이름이 동일한 빈을 선택한다.
2. 매개변수의 식별자가 컨텍스트의 빈 이름과 일치하지 않는 경우에는 다음과 같은 선택자가 있다.
   - 빈 중 하나를 기본으로 표시한 경우(@Priamry)
   - @Qualifier 애너테이션을 사용하여 특정 빈을 명시적으로 선택
   - 어떤 빈도 기본 빈이 아니며, @Qualifer를 사용하지 않았다면 앱은 예외를 발생